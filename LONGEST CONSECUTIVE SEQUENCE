Longest Consecutive Sequence

ğŸ’¥ Extremely common in Google / Amazon / Microsoft
Tests HashSet + optimal thinking

ğŸ§  Problem Statement

Given an unsorted integer array nums, return the length of the longest consecutive elements sequence.

âš ï¸ The sequence must be continuous numbers, but not necessarily contiguous in the array.

Example 1
Input: nums = [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: [1, 2, 3, 4]

Example 2
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

ğŸš« Constraints / Traps (Interviewers Love These)

You CANNOT sort (sorting gives O(n log n), expected is O(n))

Duplicates may exist

Order doesnâ€™t matter

ğŸ’¡ Optimal Approach (Key Idea)

ğŸ‘‰ Use a HashSet

Why it works:

O(1) lookup

We only start counting when the number is the start of a sequence

ğŸ§  Algorithm (Step-by-Step)

Insert all numbers into a HashSet

For each number:

If (num - 1) does NOT exist â†’ it's a sequence start

Count how long the sequence continues (num + 1, num + 2, â€¦)

Track the maximum length

â± Complexity

Time: O(n)

Space: O(n)

âœ… Java Code
import java.util.*;

class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int longest = 0;

        for (int num : set) {
            // Check if num is start of sequence
            if (!set.contains(num - 1)) {
                int currentNum = num;
                int count = 1;

                while (set.contains(currentNum + 1)) {
                    currentNum++;
                    count++;
                }

                longest = Math.max(longest, count);
            }
        }
        return longest;
    }
}

ğŸ” Line-by-Line Explanation
if (nums.length == 0) return 0;


ğŸ‘‰ Edge case: empty array

Set<Integer> set = new HashSet<>();
for (int num : nums) {
    set.add(num);
}


ğŸ‘‰ Store all unique numbers for O(1) lookup

for (int num : set)


ğŸ‘‰ Loop through unique elements only

if (!set.contains(num - 1))


ğŸ‘‰ Ensures num is the start of a sequence
(prevents repeated work)

int currentNum = num;
int count = 1;


ğŸ‘‰ Start counting the current sequence

while (set.contains(currentNum + 1))


ğŸ‘‰ Keep extending the sequence

longest = Math.max(longest, count);


ğŸ‘‰ Update global maximum

ğŸ§ª Detailed Walkthrough
Input:
nums = [100, 4, 200, 1, 3, 2]

Step 1: HashSet
set = {100, 4, 200, 1, 3, 2}

Step 2: Iterate
num	num-1 exists?	Action
100	99 âŒ	start seq â†’ length = 1
4	3 âœ…	skip
200	199 âŒ	start seq â†’ length = 1
1	0 âŒ	start seq â†’ expand
3	2 âœ…	skip
2	1 âœ…	skip
Expanding from 1
1 â†’ 2 â†’ 3 â†’ 4
count = 4

Final Answer
4

ğŸ¯ Interview Talking Points (Say This!)

â€œI use a HashSet to achieve O(n) timeâ€

â€œOnly start counting if num âˆ’ 1 doesnâ€™t existâ€

â€œPrevents redundant sequence traversalâ€
