âœ… QUESTION 2: EDIT DISTANCE
ğŸ”¹ Problem Statement

You are given two strings:

word1

word2

You are allowed 3 operations:

Insert a character

Delete a character

Replace a character

ğŸ‘‰ Return the minimum number of operations required to convert word1 into word2.

âœ¨ Example
Input:
word1 = "horse"
word2 = "ros"

Output:
3

Explanation:
horse â†’ rorse (replace 'h' with 'r')
rorse â†’ rose  (delete 'r')
rose  â†’ ros   (delete 'e')

ğŸ§  Interview Thinking Pattern

Whenever you hear:

minimum operations

string conversion

choices at every character

ğŸ‘‰ Dynamic Programming immediately.

ğŸ§© DP Definition

Let:

dp[i][j] = minimum operations
to convert word1[0..i-1] â†’ word2[0..j-1]

ğŸ”‘ Base Cases
dp[0][j] = j   // insert all characters of word2
dp[i][0] = i   // delete all characters of word1


Why?

Converting empty string to length j â†’ j inserts

Converting length i to empty string â†’ i deletes

ğŸ”„ Transition Logic

For each character:

Case 1: Characters match
word1[i-1] == word2[j-1]
dp[i][j] = dp[i-1][j-1]


ğŸ‘‰ No operation needed

Case 2: Characters donâ€™t match

We take minimum of 3 operations:

Operation	Meaning	Formula
Insert	add char to word1	dp[i][j-1] + 1
Delete	remove char from word1	dp[i-1][j] + 1
Replace	replace char	dp[i-1][j-1] + 1
dp[i][j] = 1 + min(insert, delete, replace)

ğŸ§® Step-by-Step Example Walkthrough
word1 = "horse"
word2 = "ros"


DP Table:

      ""  r  o  s
""    0   1  2  3
h     1   1  2  3
o     2   2  1  2
r     3   2  2  2
s     4   3  3  2
e     5   4  4  3


âœ… Final Answer:

dp[5][3] = 3

â±ï¸ Time & Space Complexity

Time: O(m Ã— n)

Space: O(m Ã— n)

Where m and n are lengths of both strings.

â˜• Java Code â€“ EDIT DISTANCE
class Solution {
    public int minDistance(String word1, String word2) {

        int m = word1.length();
        int n = word2.length();

        // dp[i][j] = edit distance for word1[0..i-1] and word2[0..j-1]
        int[][] dp = new int[m + 1][n + 1];

        // Base cases
        for (int i = 0; i <= m; i++)
            dp[i][0] = i;

        for (int j = 0; j <= n; j++)
            dp[0][j] = j;

        // Fill DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                // If characters match
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // If characters don't match
                else {
                    dp[i][j] = 1 + Math.min(
                            dp[i - 1][j],      // delete
                            Math.min(
                                dp[i][j - 1],  // insert
                                dp[i - 1][j - 1] // replace
                            )
                    );
                }
            }
        }

        return dp[m][n];
    }
}

ğŸ” LINE-BY-LINE EXPLANATION
int[][] dp = new int[m + 1][n + 1];


ğŸ‘‰ DP table for all substring combinations

dp[i][0] = i;
dp[0][j] = j;


ğŸ‘‰ Converting to/from empty string

if (word1.charAt(i - 1) == word2.charAt(j - 1))


ğŸ‘‰ Matching characters â†’ no cost

1 + Math.min(...)


ğŸ‘‰ Take best among insert, delete, replace

return dp[m][n];


ğŸ‘‰ Minimum operations to convert full strings
