âœ… Redundant Connection (Unionâ€“Find / Disjoint Set)

ğŸ“ Pattern: Union Find
ğŸ“ Asked in: Amazon, Meta, Google
ğŸ“ Difficulty: Medium
ğŸ“ Why it matters: Tests cycle detection without DFS/BFS

ğŸ§© Problem Statement

You are given a list of edges representing an undirected graph.

The graph initially started as a tree

One extra edge was added, making a cycle

Your task: Return the edge that creates the cycle

ğŸ‘‰ If there are multiple answers, return the last edge that forms a cycle.

ğŸ“Œ Example
Input
edges = [[1,2],[1,3],[2,3]]

Output
[2,3]

Explanation

Adding [2,3] creates a cycle:

1
| \
2--3

ğŸš« Why NOT use DFS/BFS?

DFS for every edge â†’ O(NÂ²) worst case

Union-Find does it in almost O(1)

âœ… Optimal Approach: UNION FIND (Disjoint Set)
ğŸ§  Core Idea

Each node has a parent

If two nodes already have the same parent, adding that edge creates a cycle

ğŸªœ Algorithm Steps

Initialize parent array where each node is its own parent

For every edge (u, v):

Find parent of u and v

If same â†’ cycle found â†’ return edge

Else â†’ union them

Return the redundant edge

â± Time & Space Complexity

Time: O(N Î±(N)) â‰ˆ O(N)

Space: O(N)

(Î± = inverse Ackermann function â†’ grows VERY slowly)

ğŸ’» JAVA CODE (INTERVIEW READY)
public class RedundantConnection {

    static class UnionFind {
        int[] parent;

        UnionFind(int n) {
            parent = new int[n + 1];
            for (int i = 1; i <= n; i++) {
                parent[i] = i;
            }
        }

        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // path compression
            }
            return parent[x];
        }

        boolean union(int x, int y) {
            int px = find(x);
            int py = find(y);

            if (px == py) return false; // cycle detected

            parent[px] = py;
            return true;
        }
    }

    public static int[] findRedundantConnection(int[][] edges) {

        UnionFind uf = new UnionFind(edges.length);

        for (int[] edge : edges) {
            if (!uf.union(edge[0], edge[1])) {
                return edge;
            }
        }

        return new int[0];
    }

    public static void main(String[] args) {
        int[][] edges = {{1,2},{1,3},{2,3}};
        int[] res = findRedundantConnection(edges);
        System.out.println(res[0] + " " + res[1]);
    }
}

ğŸ” LINE-BY-LINE EXPLANATION
ğŸ”¹ Parent Initialization
parent[i] = i;


â¡ Each node is its own leader initially

ğŸ”¹ Find with Path Compression
parent[x] = find(parent[x]);


â¡ Flattens tree â†’ faster future lookups

ğŸ”¹ Union Logic
if (px == py) return false;


â¡ Nodes already connected â†’ cycle

parent[px] = py;


â¡ Merge sets

ğŸ” DRY RUN (VERY IMPORTANT)
Input:
[[1,2],[1,3],[2,3]]

Step-by-step:
Edge	Parent Result	Action
1â€“2	different	union
1â€“3	different	union
2â€“3	same parent	âŒ cycle

ğŸ“Œ Answer = [2,3]

ğŸ¯ How to Explain in Interview (Short & Strong)

â€œI used Union-Find to detect cycles efficiently.
If two nodes already belong to the same set, adding the edge creates a cycle.â€

ğŸ”¥ Common Interview Follow-Ups

Difference between Union-Find vs DFS

What is path compression

Can this work for directed graphs? (âŒ No)
