âœ… QUESTION 2: MIN STACK

ğŸ“Œ Asked in: Amazon, Google, Microsoft, Meta
ğŸ“Œ Concepts: Stack, Design, O(1) optimization
ğŸ“Œ Difficulty: Medium
ğŸ“Œ EXTREMELY COMMON in coding interviews

ğŸ” PROBLEM STATEMENT

Design a stack that supports all operations in O(1) time:

push(x) â†’ push element x

pop() â†’ remove top element

top() â†’ return top element

getMin() â†’ return the minimum element in the stack

âš ï¸ Important constraint:
getMin() must work in O(1) time.

ğŸ§ª Example
Input:
push(5)
push(2)
push(8)
getMin()  â†’ 2
pop()
getMin()  â†’ 2
pop()
getMin()  â†’ 5

âŒ NAIVE APPROACH (REJECTED IN INTERVIEW)

Use one stack

Every time getMin() is called â†’ traverse stack

â›” Time: O(n)
âŒ Interviewer will reject immediately

ğŸ§  OPTIMIZED IDEA (INTERVIEW SOLUTION)
ğŸ’¡ Use TWO STACKS

1ï¸âƒ£ Main Stack â†’ stores all values
2ï¸âƒ£ Min Stack â†’ stores minimum at each level

ğŸ‘‰ At any point:

top of minStack = minimum element so far

ğŸ› ï¸ ALGORITHM (STEP BY STEP)
â–¶ push(x)

Push x to main stack

If minStack is empty OR x <= minStack.peek()

Push x into minStack

â–¶ pop()

Pop from main stack

If popped value == minStack.peek()

Pop from minStack also

â–¶ top()

Return mainStack.peek()

â–¶ getMin()

Return minStack.peek()

â±ï¸ COMPLEXITY
Operation	Time
push	O(1)
pop	O(1)
top	O(1)
getMin	O(1)

| Space | O(n) |

ğŸ’» JAVA CODE (INTERVIEW-PERFECT)
import java.util.Stack;

class MinStack {

    Stack<Integer> stack;
    Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {

        stack.push(val);

        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {

        int removed = stack.pop();

        if (removed == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

ğŸ§¾ LINE-BY-LINE EXPLANATION (VERY CLEAR)
Stack<Integer> stack;
Stack<Integer> minStack;


â¡ï¸ Two stacks:

stack â†’ normal stack

minStack â†’ tracks minimums

stack.push(val);


â¡ï¸ Always push value to main stack

if (minStack.isEmpty() || val <= minStack.peek())


â¡ï¸ If new value is new minimum, store it

if (removed == minStack.peek())


â¡ï¸ Remove min only if it was popped

return minStack.peek();


â¡ï¸ Top of minStack = current minimum

ğŸ§ª DRY RUN (LOGIC IN ACTION)
Operations:
push(5)


stack = [5]
minStack = [5]

push(2)


stack = [5,2]
minStack = [5,2]

push(8)


stack = [5,2,8]
minStack = [5,2]

getMin() â†’ 2

pop() â†’ removes 8


minStack unchanged

pop() â†’ removes 2


minStack pops 2

getMin() â†’ 5


âœ” Always correct
âœ” O(1) guaranteed

ğŸ¯ WHY INTERVIEWERS LOVE THIS QUESTION

âœ… Tests data-structure design
âœ… Tests O(1) optimization thinking
âœ… Looks simple but filters many candidates
âœ… Often followed by LRU Cache
