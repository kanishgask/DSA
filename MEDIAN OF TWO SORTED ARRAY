‚úÖ QUESTION 4: MEDIAN OF TWO SORTED ARRAYS

üìå Asked in: Google, Amazon, Microsoft
üìå Concepts: Binary Search, Array Partition
üìå Difficulty: Hard (Google-favorite)
üìå Very high interview value

üîç Problem Statement

You are given two sorted arrays nums1 and nums2 of sizes m and n.

üëâ Find the median of the two sorted arrays in
O(log(min(m, n))) time.

‚ùó You must not merge the arrays.

üß™ Examples
Example 1
nums1 = [1, 3]
nums2 = [2]

Output: 2.0

Example 2
nums1 = [1, 2]
nums2 = [3, 4]

Output: 2.5

üß† Core Idea (VERY IMPORTANT)
üí° Use Binary Search on the Smaller Array

We partition both arrays such that:

Left part contains (m + n + 1) / 2 elements


And:

max(left1, left2) ‚â§ min(right1, right2)


Once this condition is met ‚Üí median found üéØ

üõ†Ô∏è Algorithm (Step-by-Step)

1Ô∏è‚É£ Ensure nums1 is the smaller array
2Ô∏è‚É£ Apply binary search on nums1
3Ô∏è‚É£ Calculate partitions:

cut1 + cut2 = (m + n + 1) / 2


4Ô∏è‚É£ Compare boundary values
5Ô∏è‚É£ Adjust binary search until valid partition is found
6Ô∏è‚É£ Calculate median based on total length (odd/even)

‚è±Ô∏è Complexity
Type	Value
Time	O(log(min(m, n)))
Space	O(1)
üíª Java Code (Interview-Perfect)
class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {

        if (A.length > B.length) {
            return findMedianSortedArrays(B, A);
        }

        int m = A.length;
        int n = B.length;

        int low = 0, high = m;

        while (low <= high) {

            int cut1 = (low + high) / 2;
            int cut2 = (m + n + 1) / 2 - cut1;

            int left1  = (cut1 == 0) ? Integer.MIN_VALUE : A[cut1 - 1];
            int left2  = (cut2 == 0) ? Integer.MIN_VALUE : B[cut2 - 1];

            int right1 = (cut1 == m) ? Integer.MAX_VALUE : A[cut1];
            int right2 = (cut2 == n) ? Integer.MAX_VALUE : B[cut2];

            if (left1 <= right2 && left2 <= right1) {

                if ((m + n) % 2 == 0) {
                    return (Math.max(left1, left2) +
                            Math.min(right1, right2)) / 2.0;
                } else {
                    return Math.max(left1, left2);
                }

            } else if (left1 > right2) {
                high = cut1 - 1;
            } else {
                low = cut1 + 1;
            }
        }

        return 0.0; // never reached
    }
}

üßæ Line-by-Line Explanation
if (A.length > B.length)


‚û°Ô∏è Binary search must be on smaller array

int cut2 = (m + n + 1) / 2 - cut1;


‚û°Ô∏è Keeps total left elements balanced

left1 <= right2 && left2 <= right1


‚û°Ô∏è Correct partition found üéØ

Integer.MIN_VALUE / MAX_VALUE


‚û°Ô∏è Handles edge cases safely

üß™ Dry Run Example
nums1 = [1, 2]
nums2 = [3, 4]


Correct partition ‚Üí left: [1,2] | [3]

Median = (2 + 3) / 2 = 2.5

üéØ Why Interviewers Love This

‚úî Tests advanced binary search
‚úî Tests logic & edge cases
‚úî Filters strong candidates
‚úî Google / Amazon favorite
