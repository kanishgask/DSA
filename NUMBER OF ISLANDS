âœ… NUMBER OF ISLANDS

ğŸ“Œ Asked in: Amazon, Google, Microsoft, Flipkart
ğŸ“Œ Concepts: DFS / BFS, Graph, Matrix Traversal
ğŸ“Œ Difficulty: Medium

ğŸ” Problem Statement

You are given a 2D grid of characters:

'1' â†’ Land

'0' â†’ Water

An island is formed by connecting adjacent lands horizontally or vertically.

ğŸ‘‰ Count the total number of islands.

ğŸ§ª Example
Input
grid = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]

Output
3

Explanation

Island 1 â†’ Top-left block

Island 2 â†’ Single 1 in middle

Island 3 â†’ Two connected 1s on bottom-right

ğŸ§  Core Idea (Very Important)

ğŸ‘‰ Treat the grid as a graph
ğŸ‘‰ Every '1' is a node
ğŸ‘‰ Use DFS or BFS to mark the entire island as visited

ğŸ› ï¸ Algorithm (DFS Approach)

1ï¸âƒ£ Initialize count = 0
2ï¸âƒ£ Traverse every cell in the grid
3ï¸âƒ£ If cell is '1':

Increase island count

Run DFS to mark all connected land as '0'
4ï¸âƒ£ Continue until grid is fully processed

â±ï¸ Complexity Analysis
Type	Value
Time	O(m Ã— n)
Space	O(m Ã— n) (DFS recursion stack)
ğŸ’» Java Code (Interview-Ready)
class Solution {

    public int numIslands(char[][] grid) {

        if (grid == null || grid.length == 0) {
            return 0;
        }

        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    private void dfs(char[][] grid, int i, int j) {

        if (i < 0 || j < 0 ||
            i >= grid.length || j >= grid[0].length ||
            grid[i][j] == '0') {
            return;
        }

        grid[i][j] = '0'; // mark as visited

        dfs(grid, i + 1, j); // down
        dfs(grid, i - 1, j); // up
        dfs(grid, i, j + 1); // right
        dfs(grid, i, j - 1); // left
    }
}

ğŸ§¾ Line-by-Line Explanation
ğŸ”¹ Main Loop
if (grid[i][j] == '1')


â¡ï¸ Found unvisited land â†’ start a new island

count++;
dfs(grid, i, j);


â¡ï¸ Count the island
â¡ï¸ DFS marks the entire island as visited

ğŸ”¹ DFS Function
if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)


â¡ï¸ Boundary condition

grid[i][j] = '0';


â¡ï¸ Mark land as visited to avoid recounting

dfs(grid, i + 1, j);
dfs(grid, i - 1, j);
dfs(grid, i, j + 1);
dfs(grid, i, j - 1);


â¡ï¸ Explore all 4 directions

ğŸ§ª Dry Run (Small Example)
1 1 0
1 0 0
0 0 1


First island found at (0,0) â†’ DFS covers (0,1) & (1,0)

Second island at (2,2)

â¡ï¸ Output = 2

ğŸ¯ Why Interviewers Love This Question

âœ” Tests DFS/BFS
âœ” Tests grid traversal
âœ” Tests boundary handling
âœ” Real-world mapping problem
