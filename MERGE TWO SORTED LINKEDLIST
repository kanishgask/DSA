ğŸ”— MERGE TWO SORTED LINKED LISTS

(Classic Linked List interview problem)

ğŸ”¹ Problem Definition (How Interviewer Says It)

You are given two sorted linked lists l1 and l2.
Merge them into one sorted linked list and return its head.

ğŸ‘‰ You must not create new nodes (just rearrange pointers).

ğŸ”¹ Example
Input
l1 = 1 â†’ 3 â†’ 4
l2 = 1 â†’ 2 â†’ 5

Output
1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

âŒ Brute Force Idea (Donâ€™t say this first)

Copy values into array

Sort

Create new list

âŒ Extra space, not pointer-based
âŒ Interviewers donâ€™t like this

âœ… Optimal Approach: POINTER MANIPULATION
ğŸ”‘ Core Idea (VERY IMPORTANT)

Both lists are already sorted

Compare nodes one by one

Attach the smaller node

Move that list forward

ğŸ’¡ This is exactly like the merge step in Merge Sort

ğŸ”¹ Why Do We Use a Dummy Node?

Dummy node:

Avoids handling head separately

Makes code clean and bug-free

Real head is dummy.next

ğŸ”¹ Step-by-Step Algorithm

Create a dummy node

Use current pointer starting at dummy

While both lists are not null:

Compare l1.val and l2.val

Attach smaller node

Move pointer

Attach remaining list

Return dummy.next

ğŸ”¹ Java Code (Interview Perfect)
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {

            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }

            current = current.next;
        }

        if (l1 != null) {
            current.next = l1;
        }

        if (l2 != null) {
            current.next = l2;
        }

        return dummy.next;
    }
}

ğŸ§  LINE-BY-LINE CODE EXPLANATION (DETAILED)
ğŸ”¹ Dummy Node Creation
ListNode dummy = new ListNode(-1);


âœ” Fake node before head
âœ” Avoids special case for first element

ListNode current = dummy;


âœ” Pointer that builds the merged list
âœ” Always points to last node in result

ğŸ”¹ Main Loop
while (l1 != null && l2 != null) {


âœ” Continue while both lists have nodes

if (l1.val <= l2.val) {


âœ” Compare current values
âœ” Choose smaller value to keep sorted order

current.next = l1;


âœ” Attach node from l1 to merged list
âœ” NO new node created

l1 = l1.next;


âœ” Move l1 pointer forward

else {
    current.next = l2;
    l2 = l2.next;
}


âœ” Same logic for l2

current = current.next;


âœ” Move merged list pointer forward

ğŸ”¹ Attach Remaining Nodes
if (l1 != null) {
    current.next = l1;
}


âœ” If l2 ended first, attach rest of l1

if (l2 != null) {
    current.next = l2;
}


âœ” If l1 ended first, attach rest of l2

ğŸ”¹ Return Answer
return dummy.next;


âœ” Actual head starts after dummy

ğŸ” Full Dry Run (Step by Step)
Initial
l1 â†’ 1 â†’ 3 â†’ 4
l2 â†’ 1 â†’ 2 â†’ 5
dummy â†’ -1
current â†’ dummy

Step 1
Compare 1 & 1 â†’ take l1
merged: -1 â†’ 1

Step 2
Compare 3 & 1 â†’ take l2
merged: -1 â†’ 1 â†’ 1

Step 3
Compare 3 & 2 â†’ take l2
merged: -1 â†’ 1 â†’ 1 â†’ 2

Step 4
Compare 3 & 5 â†’ take l1
merged: -1 â†’ 1 â†’ 1 â†’ 2 â†’ 3

Step 5
Compare 4 & 5 â†’ take l1
merged: -1 â†’ 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4

Attach remaining
merged: -1 â†’ 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5


Return:

1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

â± Time & Space Complexity
Metric	Value
Time	O(n + m)
Space	O(1)
ğŸ¯ Interview One-Liner Explanation

â€œI use a dummy node and compare both list values node by node, attaching the smaller one each time. Since lists are sorted, this guarantees a sorted merge in linear time.â€
