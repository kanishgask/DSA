DSA Question 6: Merge Intervals (Java)
Problem Statement

You are given a collection of intervals represented as [start, end]. Your task is to merge all overlapping intervals and return the resulting non-overlapping intervals.

Example Problem:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: 
- [1,3] and [2,6] overlap, so merge them into [1,6].
- [8,10] and [15,18] don’t overlap, so they remain the same.


Constraints:

Intervals can be in any order

0 <= intervals.length <= 10^4

0 <= start <= end <= 10^5

Algorithm (Step by Step)

Sort intervals by their start times → ensures overlapping intervals are next to each other.

Initialize a list merged to store merged intervals.

Iterate through all intervals:

If merged is empty or current interval’s start > last merged interval’s end → no overlap → add current interval.

Else → intervals overlap → merge by updating last merged interval’s end:

lastMerged.end = max(lastMerged.end, current.end)


Return the list merged.

Time Complexity:

Sorting → O(n log n)

Iterating → O(n)

Total → O(n log n)

Space Complexity: O(n) for the result list

Java Code
import java.util.*;

public class MergeIntervals {

    public static int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) return intervals;

        // Step 1: Sort intervals by start
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        List<int[]> merged = new ArrayList<>();
        int[] current = intervals[0];
        merged.add(current);

        for (int[] interval : intervals) {
            if (interval[0] <= current[1]) {
                // Overlap → merge intervals
                current[1] = Math.max(current[1], interval[1]);
            } else {
                // No overlap → add new interval
                current = interval;
                merged.add(current);
            }
        }

        return merged.toArray(new int[merged.size()][]);
    }

    public static void main(String[] args) {
        int[][] intervals = {{1,3},{2,6},{8,10},{15,18}};
        int[][] result = merge(intervals);

        System.out.println("Merged Intervals:");
        for (int[] interval : result) {
            System.out.println(Arrays.toString(interval));
        }
    }
}

Code Explanation

Sorting:

Sorting ensures we only need to check the previous interval to detect overlap.

Example: [[1,3],[2,6],[8,10],[15,18]] → sorted by start → same order.

Merging Logic:

Keep a current interval (last merged).

If interval[0] <= current[1] → intervals overlap → merge.

Else → intervals don’t overlap → move current to new interval and add to result.

Result:

Use List<int[]> to store intervals dynamically.

Convert to int[][] before returning.

Dry Run (Example Problem)
Intervals: [[1,3],[2,6],[8,10],[15,18]]

Step 1: Sort → [[1,3],[2,6],[8,10],[15,18]]

Step 2: Initialize merged = [[1,3]], current = [1,3]

Step 3: interval = [2,6]
        2 <= 3 → overlap → merge → current[1] = max(3,6)=6
        merged = [[1,6]]

Step 4: interval = [8,10]
        8 > 6 → no overlap → current = [8,10] → merged = [[1,6],[8,10]]

Step 5: interval = [15,18]
        15 > 10 → no overlap → current = [15,18] → merged = [[1,6],[8,10],[15,18]]

Output: [[1,6],[8,10],[15,18]]


✅ Summary

Time Complexity: O(n log n) due to sorting

Space Complexity: O(n) for result list

Use Case: Important for interval scheduling, calendar problems, and coding interviews
