âœ… QUESTION 4: VALID BST (Binary Search Tree)

ğŸ“Œ Asked in: Amazon, Microsoft, Google
ğŸ“Œ Concepts: Binary Tree, Recursion, DFS
ğŸ“Œ Difficulty: Medium
ğŸ“Œ Very commonly asked in coding rounds and interviews

ğŸ” PROBLEM STATEMENT

Given the root of a binary tree, determine if it is a valid Binary Search Tree (BST).

BST rules:

Left subtree of a node contains only nodes with keys less than the nodeâ€™s key.

Right subtree of a node contains only nodes with keys greater than the nodeâ€™s key.

Both left and right subtrees must also be BSTs.

ğŸ§ª Example 1
    2
   / \
  1   3


Output: true

Explanation:

Left child 1 < 2

Right child 3 > 2

Both left & right subtrees are valid â†’ âœ…

ğŸ§ª Example 2
    5
   / \
  1   4
     / \
    3   6


Output: false

Explanation:

Node 4 is in the right subtree of 5 but has a left child 3 < 5 â†’ âŒ violates BST

ğŸ§  CORE IDEA (INTERVIEW INSIGHT)
âœ… Use recursion + range check

Each node must satisfy:

min < node.val < max


For left child â†’ max = parent value

For right child â†’ min = parent value

ğŸ› ï¸ ALGORITHM (STEP-BY-STEP)

Start at root with min = -âˆ, max = +âˆ

Check if node value is in (min, max)

If no â†’ return false

Recursively check left and right subtrees

Left â†’ max = node.val

Right â†’ min = node.val

If all nodes satisfy â†’ return true

â±ï¸ COMPLEXITY
Metric	Value
Time	O(n) â†’ visit every node
Space	O(h) â†’ recursion stack (h = height)
ğŸ’» JAVA CODE (INTERVIEW-READY)
class Solution {

    public boolean isValidBST(TreeNode root) {
        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean helper(TreeNode node, long min, long max) {
        if (node == null) return true;

        // current node must be in (min, max)
        if (node.val <= min || node.val >= max) return false;

        // left subtree: max = node.val
        // right subtree: min = node.val
        return helper(node.left, min, node.val) &&
               helper(node.right, node.val, max);
    }
}

ğŸ§¾ LINE-BY-LINE EXPLANATION
return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);


â¡ï¸ Start recursion with full valid range

if (node == null) return true;


â¡ï¸ Empty node â†’ valid by definition

if (node.val <= min || node.val >= max) return false;


â¡ï¸ Node violates BST property â†’ stop recursion

return helper(node.left, min, node.val) &&
       helper(node.right, node.val, max);


â¡ï¸ Recursively validate left & right subtrees with updated ranges

ğŸ§ª DRY RUN (LOGIC IN ACTION)
Tree:
    5
   / \
  1   4
     / \
    3   6


Root 5 â†’ valid (-âˆ, +âˆ) âœ…

Left 1 â†’ valid (-âˆ,5) âœ…

Right 4 â†’ valid (5, +âˆ) âŒ 4 < 5 â†’ invalid BST

Output â†’ false

ğŸ¯ WHY INTERVIEWERS LOVE THIS

âœ… Tests tree recursion
âœ… Checks logical thinking about ranges
âœ… Many candidates fail by only comparing parent-child, not entire range
âœ… Good prelude to validate BST + operations questions
