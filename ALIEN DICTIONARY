âœ… QUESTION 5: ALIEN DICTIONARY (Topological Sort)
ğŸ”¹ Problem Statement

You are given an array of words sorted lexicographically according to an unknown alien language.

ğŸ‘‰ Return the order of characters in the alien language.

If the order is invalid, return empty string.

âœ¨ Example
Input:
words = ["wrt", "wrf", "er", "ett", "rftt"]

Output:
"wertf"

ğŸ§  Interview Thinking Pattern

Keywords:

Unknown character order

Given sorted words

Need to infer rules

ğŸ‘‰ This is a Graph + Topological Sort problem.

ğŸ§© Key Insight

If:

"wrt" < "wrf"


ğŸ‘‰ Compare character by character:

w == w

r == r

t != f

â¡ï¸ So:

t â†’ f   (t comes before f)


This is a directed edge.

ğŸ§± Graph Construction

Every unique character â†’ Node

For every adjacent word pair:

Find first mismatching char

Add edge c1 â†’ c2

Use Topological Sort (BFS / Kahnâ€™s Algorithm)

ğŸ”„ Algorithm Steps
Step 1: Build Graph

Adjacency list

In-degree array

Step 2: Add edges from word comparisons
Step 3: BFS Topological Sort

Start with nodes having indegree = 0

Remove node, reduce neighborsâ€™ indegree

Append to result

ğŸ§® Example Walkthrough
words = ["wrt","wrf","er","ett","rftt"]


Derived edges:

t â†’ f
w â†’ e
r â†’ t
e â†’ r


Graph order:

w â†’ e â†’ r â†’ t â†’ f


Result:

"wertf"

â±ï¸ Time & Space Complexity

Time: O(N Ã— L)

Space: O(K)
Where:

N = number of words

L = max word length

K = unique characters

â˜• Java Code â€“ ALIEN DICTIONARY
import java.util.*;

class Solution {
    public String alienOrder(String[] words) {

        Map<Character, Set<Character>> graph = new HashMap<>();
        Map<Character, Integer> indegree = new HashMap<>();

        // Initialize graph
        for (String word : words) {
            for (char c : word.toCharArray()) {
                graph.putIfAbsent(c, new HashSet<>());
                indegree.putIfAbsent(c, 0);
            }
        }

        // Build edges
        for (int i = 0; i < words.length - 1; i++) {

            String w1 = words[i];
            String w2 = words[i + 1];

            // Invalid case: prefix problem
            if (w1.length() > w2.length() && w1.startsWith(w2))
                return "";

            int len = Math.min(w1.length(), w2.length());

            for (int j = 0; j < len; j++) {
                char c1 = w1.charAt(j);
                char c2 = w2.charAt(j);

                if (c1 != c2) {
                    if (!graph.get(c1).contains(c2)) {
                        graph.get(c1).add(c2);
                        indegree.put(c2, indegree.get(c2) + 1);
                    }
                    break;
                }
            }
        }

        // Topological Sort (BFS)
        Queue<Character> queue = new LinkedList<>();
        StringBuilder result = new StringBuilder();

        for (char c : indegree.keySet()) {
            if (indegree.get(c) == 0)
                queue.offer(c);
        }

        while (!queue.isEmpty()) {
            char curr = queue.poll();
            result.append(curr);

            for (char next : graph.get(curr)) {
                indegree.put(next, indegree.get(next) - 1);
                if (indegree.get(next) == 0)
                    queue.offer(next);
            }
        }

        // Cycle check
        return result.length() == indegree.size() ? result.toString() : "";
    }
}

ğŸ” LINE-BY-LINE EXPLANATION (KEY POINTS)
graph.putIfAbsent(c, new HashSet<>());
indegree.putIfAbsent(c, 0);


ğŸ‘‰ Ensure all characters exist in graph

if (w1.startsWith(w2)) return "";


ğŸ‘‰ Invalid ordering edge case

graph.get(c1).add(c2);
indegree.put(c2, indegree.get(c2) + 1);


ğŸ‘‰ Build directed graph

if (indegree.get(c) == 0)
    queue.offer(c);


ğŸ‘‰ Start BFS from nodes with no dependencies

return result.length() == indegree.size() ? result.toString() : "";


ğŸ‘‰ Cycle detection

ğŸ¯ Interview GOLD Tips

If interviewer asks:

Why BFS instead of DFS?

ğŸ‘‰ Answer:

BFS (Kahnâ€™s) easily detects cycles

Order is built incrementally

More intuitive for dependency problems
