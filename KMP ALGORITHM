âœ… KMP ALGORITHM (Knuthâ€“Morrisâ€“Pratt)
ðŸ”¹ Problem Statement (Interview Version)

Given a text string txt and a pattern string pat, find the first index where pat appears in txt.

ðŸ“Œ Return -1 if the pattern does not exist.

ðŸ“Œ Example
Text    = "ababcabcabababd"
Pattern = "ababd"

Output = 10

ðŸ§  Why KMP?
Naive Approach

Try matching from every index

Worst case: O(n Ã— m)

ðŸ”¥ KMP Optimization

Avoid re-checking characters

Use LPS array (Longest Prefix which is also Suffix)

ðŸ§© Core Concept: LPS Array
ðŸ”¹ LPS Meaning
lps[i] = length of longest proper prefix of pattern[0..i]
         which is also a suffix

ðŸ”¹ Example: Pattern = "ababd"
Index	Char	LPS
0	a	0
1	b	0
2	a	1
3	b	2
4	d	0

LPS = [0, 0, 1, 2, 0]

ðŸ›  Step 1: Build LPS Array (IMPORTANT)
ðŸ’» Java Code (LPS)
class Solution {
    private void buildLPS(String pat, int[] lps) {
        int len = 0;
        lps[0] = 0;
        int i = 1;

        while (i < pat.length()) {
            if (pat.charAt(i) == pat.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
    }

ðŸ§  Whatâ€™s Happening?

len tracks prefix length

On mismatch, we donâ€™t restart

Jump using lps[len-1]

ðŸ›  Step 2: Pattern Searching Using LPS
ðŸ’» Full Java Code (Interview-Ready)
class Solution {
    public int strStr(String txt, String pat) {
        if (pat.length() == 0) return 0;

        int n = txt.length();
        int m = pat.length();
        int[] lps = new int[m];

        // Build LPS
        buildLPS(pat, lps);

        int i = 0, j = 0;

        while (i < n) {
            if (txt.charAt(i) == pat.charAt(j)) {
                i++;
                j++;
            }

            if (j == m) {
                return i - j; // match found
            } else if (i < n && txt.charAt(i) != pat.charAt(j)) {
                if (j != 0)
                    j = lps[j - 1];
                else
                    i++;
            }
        }
        return -1;
    }

    private void buildLPS(String pat, int[] lps) {
        int len = 0;
        lps[0] = 0;
        int i = 1;

        while (i < pat.length()) {
            if (pat.charAt(i) == pat.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
    }
}

ðŸªœ Dry Run (Core Idea)

At mismatch:

Do NOT move text pointer back
Move pattern pointer using LPS


Thatâ€™s the magic.

â± Complexity
Type	Complexity
Time	O(n + m)
Space	O(m)
ðŸŽ¯ What to SAY in Interview

â€œKMP improves brute-force string matching by preprocessing the pattern into an LPS array.
On mismatch, we shift the pattern intelligently instead of re-checking characters.â€
