âœ… QUESTION 5: DIAMETER OF BINARY TREE

ğŸ“Œ Asked in: Amazon, Microsoft, Google
ğŸ“Œ Concepts: Binary Tree, DFS, Recursion
ğŸ“Œ Difficulty: Medium

ğŸ” PROBLEM STATEMENT

Given the root of a binary tree, return the diameter of the tree.

Diameter = length of the longest path between any two nodes in the tree.

The path may or may not pass through the root

Length = number of edges in the path

ğŸ§ª Example 1
Input:
      1
     / \
    2   3
   / \
  4   5


Output: 3

Explanation:

Longest path = 4 â†’ 2 â†’ 1 â†’ 3

Number of edges = 3

ğŸ§ª Example 2
Input:
      1
       \
        2
       / \
      3   4


Output: 3

Explanation:

Longest path = 3 â†’ 2 â†’ 4 â†’ 1

Number of edges = 3

ğŸ§  CORE IDEA (INTERVIEW INSIGHT)

Use DFS / recursion

At each node:

Find height of left subtree

Find height of right subtree

Diameter through node = leftHeight + rightHeight

Update max diameter globally

Return height to parent = 1 + max(leftHeight, rightHeight)

ğŸ› ï¸ ALGORITHM (STEP-BY-STEP)

Initialize maxDiameter = 0

Call DFS from root

For each node:

Recursively get leftHeight & rightHeight

Update maxDiameter = max(maxDiameter, leftHeight + rightHeight)

Return 1 + max(leftHeight, rightHeight)

Return maxDiameter

â±ï¸ COMPLEXITY
Metric	Value
Time	O(n) â†’ visit every node once
Space	O(h) â†’ recursion stack, h = height of tree
ğŸ’» JAVA CODE (INTERVIEW-READY)
class Solution {

    private int maxDiameter = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return maxDiameter;
    }

    private int dfs(TreeNode node) {
        if (node == null) return 0;

        int leftHeight = dfs(node.left);
        int rightHeight = dfs(node.right);

        // update diameter at this node
        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);

        // return height for parent
        return 1 + Math.max(leftHeight, rightHeight);
    }
}

ğŸ§¾ LINE-BY-LINE EXPLANATION
private int maxDiameter = 0;


â¡ï¸ Stores the maximum diameter found so far

if (node == null) return 0;


â¡ï¸ Null node â†’ height = 0

int leftHeight = dfs(node.left);
int rightHeight = dfs(node.right);


â¡ï¸ Recursively find heights of left and right subtrees

maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);


â¡ï¸ Update diameter at current node:

diameter = edges in path = leftHeight + rightHeight

return 1 + Math.max(leftHeight, rightHeight);


â¡ï¸ Return height for parent computation

ğŸ§ª DRY RUN (LOGIC IN ACTION)

Tree:

      1
     / \
    2   3
   / \
  4   5


DFS steps:

Node 4 â†’ left=0, right=0 â†’ diameter at 4=0 â†’ return height=1

Node 5 â†’ height=1 â†’ diameter at 5=0

Node 2 â†’ left=1, right=1 â†’ diameter=2 â†’ return height=2

Node 3 â†’ height=1 â†’ diameter at root = left+right=2+1=3

âœ… Max diameter = 3

ğŸ¯ WHY INTERVIEWERS LOVE THIS

âœ… Tests DFS & recursion
âœ… Tests ability to track global info while returning local info
âœ… Standard tree problem for FAANG-level coding rounds
