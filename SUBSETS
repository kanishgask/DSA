âœ… SUBSETS (Power Set)
ğŸ”¹ Problem Statement (Interview Version)

Given an integer array nums with unique elements, return all possible subsets (the power set).

ğŸ‘‰ The solution must not contain duplicate subsets.
ğŸ‘‰ Order of subsets does not matter.

ğŸ“Œ Example
Input: nums = [1, 2, 3]

Output:
[
  [],
  [1],
  [2],
  [3],
  [1,2],
  [1,3],
  [2,3],
  [1,2,3]
]

ğŸ§  Core Interview Insight

For each element, you have 2 choices:

Include it

Exclude it

So for n elements:

Total subsets = 2â¿


This is a classic BACKTRACKING problem.

âœ… Approach: Backtracking (Most Preferred)
ğŸ”¹ Idea

Start with an empty subset

At each index:

Pick the element

Donâ€™t pick the element

Every path you build is a valid subset

ğŸªœ Step-by-Step Dry Run

Input: [1,2]

Start: []
 â”œâ”€â”€ include 1 â†’ [1]
 â”‚    â”œâ”€â”€ include 2 â†’ [1,2]
 â”‚    â””â”€â”€ exclude 2 â†’ [1]
 â””â”€â”€ exclude 1 â†’ []
      â”œâ”€â”€ include 2 â†’ [2]
      â””â”€â”€ exclude 2 â†’ []


Final subsets:

[], [1], [2], [1,2]

ğŸ’» Java Code (Interview-Ready)
import java.util.*;

class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(0, nums, new ArrayList<>(), result);
        return result;
    }

    private void backtrack(int index, int[] nums, List<Integer> current, List<List<Integer>> result) {
        // Step 1: Add current subset to result
        result.add(new ArrayList<>(current));

        // Step 2: Explore choices
        for (int i = index; i < nums.length; i++) {
            // Choose
            current.add(nums[i]);

            // Explore
            backtrack(i + 1, nums, current, result);

            // Un-choose (Backtrack)
            current.remove(current.size() - 1);
        }
    }
}

ğŸ§© Line-by-Line Explanation
List<List<Integer>> result = new ArrayList<>();


â¡ Stores all subsets

backtrack(0, nums, new ArrayList<>(), result);


â¡ Start from index 0 with an empty subset

result.add(new ArrayList<>(current));


â¡ Every state is a valid subset, so add a copy

âš ï¸ Copy is important to avoid reference changes

for (int i = index; i < nums.length; i++)


â¡ Try all remaining elements starting from index

current.add(nums[i]);


â¡ Choose the element

backtrack(i + 1, nums, current, result);


â¡ Move to next index (no reuse of same element)

current.remove(current.size() - 1);


â¡ Undo the choice (BACKTRACK)

â± Time & Space Complexity
Metric	Value
Time	O(2â¿)
Space	O(n) (recursion stack)
Output size	O(2â¿)
