âœ… Longest Prefix Which Is Also Suffix (KMP Algorithm)
ğŸ§© Problem Statement

You are given a string s.

Find the length of the longest proper prefix of the string which is also a suffix.

ğŸ”¹ Definitions

Prefix: Starts from index 0

Suffix: Ends at last index

Proper prefix/suffix: Cannot be the entire string

ğŸ“Œ Example 1
Input:  "abab"
Output: 2
Explanation: "ab" is both prefix and suffix

ğŸ“Œ Example 2
Input:  "aaaa"
Output: 3
Explanation: "aaa" is the longest proper prefix & suffix

ğŸ“Œ Example 3
Input:  "abcab"
Output: 2
Explanation: "ab"

ğŸš« Naive Approach (Why NOT use it)

Try all prefixes and suffixes â†’
â›” Time Complexity: O(nÂ²) â†’ BAD for interviews

âœ… Optimal Approach: KMP Prefix Array (LPS Array)

We use KMP (Knuthâ€“Morrisâ€“Pratt) preprocessing.

ğŸ§  Core Idea (Very Important)

We create an array called LPS[]

lps[i] â†’ length of the longest prefix which is also suffix for substring s[0â€¦i]

ğŸ‘‰ Final Answer = lps[n-1]

ğŸªœ Algorithm Steps

Initialize:

lps[0] = 0

len = 0 â†’ length of previous longest prefix suffix

Start from index i = 1

Compare s[i] with s[len]

If match â†’ len++, set lps[i] = len

If mismatch:

If len != 0 â†’ len = lps[len - 1]

Else â†’ lps[i] = 0, move i

â± Complexity

Time: O(n)

Space: O(n)

ğŸ’» Java Code (INTERVIEW STANDARD)
public class LongestPrefixSuffix {

    public static int longestPrefixSuffix(String s) {
        int n = s.length();

        // LPS array
        int[] lps = new int[n];

        // length of the previous longest prefix suffix
        int len = 0;

        // lps[0] is always 0
        int i = 1;

        while (i < n) {

            // Case 1: Characters match
            if (s.charAt(i) == s.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            }
            // Case 2: Mismatch
            else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }

        // Last value of LPS gives answer
        return lps[n - 1];
    }

    public static void main(String[] args) {
        String s = "abab";
        System.out.println(longestPrefixSuffix(s)); // Output: 2
    }
}

ğŸ” LINE-BY-LINE EXPLANATION
int[] lps = new int[n];


â¡ Stores longest prefix-suffix lengths for each index

int len = 0;


â¡ Length of previous longest prefix-suffix

int i = 1;


â¡ Start comparing from second character

ğŸ”„ While Loop
while (i < n)


â¡ Process the full string

âœ… Character Match Case
if (s.charAt(i) == s.charAt(len))


â¡ Current character matches prefix character

len++;
lps[i] = len;
i++;


â¡ Increase prefix length and store it

âŒ Mismatch Case
if (len != 0)
    len = lps[len - 1];


â¡ Fallback to smaller prefix (core KMP idea)

else
    lps[i] = 0;
    i++;


â¡ No prefix match found

ğŸ” Dry Run (VERY IMPORTANT FOR INTERVIEW)
Input: "abab"
i	s[i]	len	lps[]
1	b	0	[0,0,,]
2	a	1	[0,0,1,_]
3	b	2	[0,0,1,2]

ğŸ“Œ Final Answer = lps[3] = 2

ğŸ¯ Interview Explanation (1â€“2 Lines)

â€œI used the KMP prefix preprocessing technique.
The LPS array efficiently tracks the longest prefix that is also a suffix for every substring in O(n) time.â€
