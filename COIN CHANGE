âœ… QUESTION 3: COIN CHANGE (Minimum Coins)
ğŸ”¹ Problem Statement

You are given:

An integer array coins[] representing different coin denominations

An integer amount

ğŸ‘‰ Return the minimum number of coins needed to make up the amount.

If it is not possible, return -1.

âœ¨ Example 1
coins = [1, 2, 5]
amount = 11

Output: 3
Explanation: 5 + 5 + 1

âœ¨ Example 2
coins = [2]
amount = 3

Output: -1

ğŸ§  Interview Thinking

Keywords:

Minimum

Unlimited usage of coins

Target amount

ğŸ‘‰ This is a Dynamic Programming (Unbounded Knapsack) problem.

ğŸ§© DP Definition

Let:

dp[i] = minimum number of coins required to make amount i

ğŸ”‘ Base Case
dp[0] = 0


(0 coins are needed to make amount 0)

All other values:

dp[i] = âˆ (initially)

ğŸ”„ Transition Formula

For each amount i from 1 to amount:

For each coin c:

if (i - c >= 0)
    dp[i] = min(dp[i], dp[i - c] + 1)

ğŸ§® Step-by-Step Example Walkthrough
Input
coins = [1, 2, 5]
amount = 11

DP table evolution:
Amount	dp value	Explanation
0	0	Base
1	1	1
2	1	2
3	2	2+1
4	2	2+2
5	1	5
6	2	5+1
7	2	5+2
8	3	5+2+1
9	3	5+2+2
10	2	5+5
11	3	5+5+1
â±ï¸ Time & Space Complexity

Time: O(amount Ã— number_of_coins)

Space: O(amount)

â˜• Java Code â€“ COIN CHANGE
import java.util.Arrays;

class Solution {
    public int coinChange(int[] coins, int amount) {

        // dp[i] = minimum coins needed to make amount i
        int[] dp = new int[amount + 1];

        // Fill dp with a large value (infinity)
        Arrays.fill(dp, amount + 1);

        // Base case
        dp[0] = 0;

        // Build dp array
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {

                // Check if we can use this coin
                if (i - coin >= 0) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // If amount cannot be formed
        return dp[amount] > amount ? -1 : dp[amount];
    }
}

ğŸ” LINE-BY-LINE EXPLANATION
int[] dp = new int[amount + 1];


ğŸ‘‰ dp array index represents amount

Arrays.fill(dp, amount + 1);


ğŸ‘‰ Represents infinity (impossible initially)

dp[0] = 0;


ğŸ‘‰ No coins needed for amount 0

for (int i = 1; i <= amount; i++)


ğŸ‘‰ Build solution from smaller subproblems

for (int coin : coins)


ğŸ‘‰ Try each coin

dp[i] = Math.min(dp[i], dp[i - coin] + 1);


ğŸ‘‰ Choose minimum coins among all possibilities

return dp[amount] > amount ? -1 : dp[amount];


ğŸ‘‰ Check if solution exists

ğŸ¯ Interview GOLD Tip

If interviewer asks:

â€œWhy greedy doesnâ€™t work?â€

ğŸ‘‰ Answer:

Greedy fails for cases like coins = [1, 3, 4], amount = 6

Greedy gives 4 + 1 + 1 = 3

Optimal is 3 + 3 = 2
