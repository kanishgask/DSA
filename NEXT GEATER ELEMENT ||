ğŸ”¹ Question 1: NEXT GREATER ELEMENT II (Circular Array)

âš ï¸ This is NOT in your list and is a very popular FAANG-style question

ğŸ§  Problem Statement

You are given a circular array nums.
For each element, find the next greater element.

The next greater element of a number x is the first number greater than x when traversing forward in the circular array.

If no such element exists, return -1 for that position.

Example
Input: nums = [1, 2, 1]
Output: [2, -1, 2]

Explanation:

For 1 â†’ next greater is 2

For 2 â†’ no greater element â†’ -1

For last 1 â†’ circular â†’ next greater is 2

ğŸ’¡ Key Interview Insight

Normal Next Greater Element uses Monotonic Stack

Circular array means we iterate twice

Time Complexity: O(n)

Space Complexity: O(n)

ğŸ›  Algorithm (Step-by-Step)

Create an array res of size n, initialize all values with -1

Use a stack to store indices

Loop from 0 to 2 * n - 1

Use i % n to simulate circular traversal

While stack is not empty and:

nums[current] > nums[stackTop]


â†’ update result

Push index only in first iteration

âœ… Java Code
import java.util.*;

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);   // Step 1: default result

        Stack<Integer> stack = new Stack<>();

        // Step 2: traverse array twice (circular)
        for (int i = 0; i < 2 * n; i++) {
            int currentIndex = i % n;

            // Step 3: resolve next greater element
            while (!stack.isEmpty() && nums[currentIndex] > nums[stack.peek()]) {
                int index = stack.pop();
                result[index] = nums[currentIndex];
            }

            // Step 4: push only first pass indices
            if (i < n) {
                stack.push(currentIndex);
            }
        }
        return result;
    }
}

ğŸ” Line-by-Line Explanation
int n = nums.length;


ğŸ‘‰ Store array size

int[] result = new int[n];
Arrays.fill(result, -1);


ğŸ‘‰ Default answer is -1 (if no greater element exists)

Stack<Integer> stack = new Stack<>();


ğŸ‘‰ Stack stores indices, not values

for (int i = 0; i < 2 * n; i++)


ğŸ‘‰ Loop twice to simulate circular behavior

int currentIndex = i % n;


ğŸ‘‰ Brings index back to [0 ... n-1]

while (!stack.isEmpty() && nums[currentIndex] > nums[stack.peek()])


ğŸ‘‰ If current element is greater than stack top

int index = stack.pop();
result[index] = nums[currentIndex];


ğŸ‘‰ Found the next greater element

if (i < n) {
    stack.push(currentIndex);
}


ğŸ‘‰ Push index only in first pass
(prevents infinite loop)

ğŸ§ª Dry Run (Walkthrough)
Input:
nums = [1, 2, 1]

Initial:
result = [-1, -1, -1]
stack = []

First Pass (i = 0 â†’ 2)
i	current	Action
0	1	push index 0
1	2	2 > 1 â†’ pop 0 â†’ result[0]=2
		push index 1
2	1	1 < 2 â†’ push index 2
stack = [1, 2]
result = [2, -1, -1]

Second Pass (i = 3 â†’ 5)
i	current	Action
3	1	1 < 1 â†’ nothing
4	2	2 > 1 â†’ pop 2 â†’ result[2]=2
5	1	nothing
Final Output
[2, -1, 2]

ğŸ¯ Interview Tips

Say â€œMonotonic decreasing stackâ€

Explain why 2*n traversal is needed

Mention O(n) time confidently
