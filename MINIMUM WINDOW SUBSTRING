Question 2: Minimum Window Substring
Problem Statement

You are given two strings:

s (the source string)

t (the target string)

Find the smallest substring in s that contains all characters of t including duplicates.

If there’s no such substring, return an empty string "".

Example:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

Explanation:
The substring "BANC" contains all characters A, B, and C from t and is the shortest possible.

Algorithm (Sliding Window)

Idea: Use two pointers to maintain a sliding window and a hash map to count characters.

Steps:

Create a hash map tMap for frequency of characters in t.

Use two pointers left and right to define the window in s.

Expand right pointer to include characters in the window.

Keep track of formed characters that match tMap.

Once all characters are formed, try shrinking the window from left to minimize length.

Keep updating the minimum length substring.

Return the substring once finished.

Time Complexity: O(N) (each character visited at most twice)
Space Complexity: O(M) where M is number of unique chars in t.

Java Code
import java.util.*;

public class MinimumWindowSubstring {

    public static String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return "";

        // Step 1: Count frequency of characters in t
        Map<Character, Integer> tMap = new HashMap<>();
        for (char c : t.toCharArray()) {
            tMap.put(c, tMap.getOrDefault(c, 0) + 1);
        }

        int required = tMap.size(); // Number of unique chars to match
        int formed = 0; // Number of chars currently matched

        Map<Character, Integer> windowCounts = new HashMap<>();
        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE, minLeft = 0;

        while (right < s.length()) {
            char c = s.charAt(right);
            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);

            // Check if current char satisfies requirement
            if (tMap.containsKey(c) && windowCounts.get(c).intValue() == tMap.get(c).intValue()) {
                formed++;
            }

            // Try shrinking window
            while (left <= right && formed == required) {
                c = s.charAt(left);

                // Update minimum window
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minLeft = left;
                }

                windowCounts.put(c, windowCounts.get(c) - 1);
                if (tMap.containsKey(c) && windowCounts.get(c).intValue() < tMap.get(c).intValue()) {
                    formed--;
                }

                left++; // Shrink from left
            }

            right++; // Expand to right
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minLeft, minLeft + minLen);
    }

    public static void main(String[] args) {
        String s = "ADOBECODEBANC";
        String t = "ABC";
        System.out.println("Minimum window substring: " + minWindow(s, t)); // Output: BANC
    }
}

Code Explanation Line by Line

Map<Character, Integer> tMap = new HashMap<>();

Stores frequency of characters in t.

int required = tMap.size();

Number of unique characters in t that must be fully matched in the window.

Map<Character, Integer> windowCounts = new HashMap<>();

Counts characters in the current sliding window.

while (right < s.length()) { ... }

Expand the window by moving the right pointer.

windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);

Add the current character to the window count.

if (tMap.containsKey(c) && windowCounts.get(c).intValue() == tMap.get(c).intValue()) formed++;

If the character count now matches the requirement, increment formed.

while (left <= right && formed == required) { ... }

Try shrinking the window from the left to minimize its size.

if (right - left + 1 < minLen) { ... }

Update minimum window length and starting index if a smaller valid window is found.

windowCounts.put(c, windowCounts.get(c) - 1);

Remove one occurrence of the character from the window as we shrink.

if (tMap.containsKey(c) && windowCounts.get(c).intValue() < tMap.get(c).intValue()) formed--;

If removing a character breaks the requirement, decrement formed.

return minLen == Integer.MAX_VALUE ? "" : s.substring(minLeft, minLeft + minLen);

Return the smallest substring or empty if no valid window exists.

Example Walkthrough
s = "ADOBECODEBANC", t = "ABC"


Step-by-step:

Initial window expands: A → AD → ADO → ADOB → ADOBE → ADOBEC → formed = 3

Shrink from left: ADOBEC → DOBEC → OBEC → BEC

Continue sliding and shrinking → smallest valid window is "BANC"
