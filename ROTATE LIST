âœ… QUESTION 6: ROTATE LIST (Linked List) / REORDER LIST

ğŸ“Œ Asked in: Amazon, Google, Microsoft
ğŸ“Œ Concepts: Linked List, Two Pointers, In-place
ğŸ“Œ Difficulty: Medium

ğŸ” PROBLEM STATEMENT

Given a singly linked list:

L0 â†’ L1 â†’ L2 â†’ â€¦ â†’ Ln-1 â†’ Ln


Reorder it to:

L0 â†’ Ln â†’ L1 â†’ Ln-1 â†’ L2 â†’ Ln-2 â†’ â€¦


Constraints:

Must do in-place (O(1) extra space)

Should traverse the list only a few times (O(n) time)

ğŸ§ª Example 1

Input:

1 â†’ 2 â†’ 3 â†’ 4


Output:

1 â†’ 4 â†’ 2 â†’ 3

ğŸ§ª Example 2

Input:

1 â†’ 2 â†’ 3 â†’ 4 â†’ 5


Output:

1 â†’ 5 â†’ 2 â†’ 4 â†’ 3

ğŸ§  CORE IDEA (INTERVIEW INSIGHT)

We can solve in 3 steps:

Find the middle node using slow & fast pointers

Reverse the second half of the list

Merge the two halves alternately

ğŸ› ï¸ ALGORITHM (STEP-BY-STEP)
Step 1: Find middle

Use slow & fast pointer

Slow moves 1 step, fast moves 2 steps

When fast reaches end â†’ slow at middle

Step 2: Reverse second half

Standard linked list reverse

Step 3: Merge two halves

Take nodes alternately from first and second half

â±ï¸ COMPLEXITY
Metric	Value
Time	O(n)
Space	O(1)
ğŸ’» JAVA CODE (INTERVIEW-READY)
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null) return;

        // Step 1: Find middle
        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Step 2: Reverse second half
        ListNode second = reverse(slow.next);
        slow.next = null; // cut first half

        // Step 3: Merge two halves
        ListNode first = head;
        while (second != null) {
            ListNode temp1 = first.next;
            ListNode temp2 = second.next;

            first.next = second;
            second.next = temp1;

            first = temp1;
            second = temp2;
        }
    }

    private ListNode reverse(ListNode head) {
        ListNode prev = null, curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
}

ğŸ§¾ LINE-BY-LINE EXPLANATION
ğŸ”¹ Find middle
ListNode slow = head, fast = head;
while (fast.next != null && fast.next.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}


Slow points to middle

Fast moves 2x â†’ stops at end

ğŸ”¹ Reverse second half
ListNode second = reverse(slow.next);
slow.next = null;


Reverse all nodes after middle

Cut first half

ğŸ”¹ Merge two halves
first.next = second;
second.next = temp1;


Take nodes alternately from first and reversed second half

ğŸ”¹ Reverse helper
ListNode prev = null, curr = head;
while (curr != null) { ... }


Standard in-place linked list reverse

ğŸ§ª DRY RUN (LOGIC IN ACTION)

Input: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

1ï¸âƒ£ Middle â†’ 3
2ï¸âƒ£ Reverse second half â†’ 5 â†’ 4
3ï¸âƒ£ Merge â†’ 1 â†’ 5 â†’ 2 â†’ 4 â†’ 3 âœ…

ğŸ¯ WHY INTERVIEWERS LOVE THIS

âœ… Tests linked list manipulation
âœ… Checks two-pointer + reverse + merge ability
âœ… Looks simple but tricky for pointer management
