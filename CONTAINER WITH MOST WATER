ğŸŒŠ CONTAINER WITH MOST WATER (Two Pointer Technique)
ğŸ”¹ Problem Definition (Interview Version)

You are given an integer array height[] of size n.
Each element represents the height of a vertical line drawn at that index.

You must choose two different lines such that:

The lines form a container

The container holds the maximum amount of water

ğŸ”¸ Formula for Water Stored
Water = min(height[i], height[j]) Ã— (j âˆ’ i)

ğŸ”¹ Example
Input:  height = [1,8,6,2,5,4,8,3,7]
Output: 49


Best choice:

Line at index 1 (height = 8)

Line at index 8 (height = 7)

min(8, 7) Ã— (8 âˆ’ 1) = 7 Ã— 7 = 49

âŒ Brute Force Approach (Why We DONâ€™T Use It)
Idea

Check every pair (i, j) and calculate area.

Time Complexity
O(nÂ²) â†’ too slow for large inputs


Interviewers will reject this for optimization.

âœ… Optimized Approach: TWO POINTER TECHNIQUE
ğŸ”¹ Key Insight (MOST IMPORTANT PART ğŸš€)

Area depends on:

Width â†’ distance between two lines

Height â†’ shorter line

ğŸ”¥ Golden Rule:

Always move the pointer with the smaller height

Why?

Width decreases anyway when moving pointers

Only moving smaller height can increase height

ğŸ”¹ Step-by-Step Algorithm

Initialize two pointers:

left = 0

right = n - 1

Calculate width:

width = right - left


Calculate height:

min(height[left], height[right])


Calculate area and update maximum

Move pointer:

If left height < right height â†’ left++

Else â†’ right--

Repeat until left < right

ğŸ”¹ Java Code (Clean & Interview Ready)
class Solution {
    public int maxArea(int[] height) {

        int left = 0;                     // starting pointer
        int right = height.length - 1;    // ending pointer
        int maxWater = 0;                 // stores maximum area

        while (left < right) {

            int width = right - left;     
            int minHeight = Math.min(height[left], height[right]);
            int currentArea = width * minHeight;

            maxWater = Math.max(maxWater, currentArea);

            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return maxWater;
    }
}

ğŸ§  LINE-BY-LINE CODE EXPLANATION (VERY DETAILED)
int left = 0;
int right = height.length - 1;


ğŸ‘‰ We start from the widest possible container
Maximum width gives best chance for max water.

int maxWater = 0;


ğŸ‘‰ Variable to track maximum water found so far

while (left < right) {


ğŸ‘‰ Loop until pointers meet
ğŸ‘‰ Once they meet, width becomes zero

int width = right - left;


ğŸ‘‰ Distance between two vertical lines

int minHeight = Math.min(height[left], height[right]);


ğŸ‘‰ Water level depends on the shorter line
ğŸ‘‰ Taller line doesn't matter beyond shorter one

int currentArea = width * minHeight;


ğŸ‘‰ Apply container area formula

maxWater = Math.max(maxWater, currentArea);


ğŸ‘‰ Store maximum area found till now

if (height[left] < height[right]) {
    left++;
}


ğŸ‘‰ Left wall is smaller
ğŸ‘‰ Moving right won't help
ğŸ‘‰ Try a taller left wall

else {
    right--;
}


ğŸ‘‰ Right wall is smaller (or equal)
ğŸ‘‰ Move right inward

return maxWater;


ğŸ‘‰ Final maximum water possible

ğŸ” Full Example Walkthrough (Step-by-Step)
Input
height = [1,8,6,2,5,4,8,3,7]

Left	Right	minHeight	Width	Area	Max
0	8	1	8	8	8
1	8	7	7	49	49
1	7	3	6	18	49
1	6	8	5	40	49
1	5	4	4	16	49

âœ” Final Answer = 49

â± Time & Space Complexity
Metric	Value
Time	O(n)
Space	O(1)
ğŸ¯ How to Explain This in an Interview (One-Liner)

â€œI use a two-pointer approach where I start from both ends and always move the pointer with smaller height because width only decreases and only a taller line can improve area.â€
