Question 4: MINIMUM NUMBER OF MEETING ROOMS

ğŸ’¥ Amazon Â· Google Â· Microsoft Â· Atlassian
Tests Greedy + Heap (Priority Queue)

ğŸ§  Problem Statement

You are given an array of meeting time intervals where
intervals[i] = [start_i, end_i].

Return the minimum number of conference rooms required to hold all meetings.

Example
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2

Explanation

Meeting 1: 0â€“30

Meeting 2: 5â€“10 (overlaps)

Meeting 3: 15â€“20 (overlaps with 0â€“30)

At most 2 meetings happen at the same time.

âŒ Common Mistakes

Counting overlaps incorrectly

Forgetting to sort meetings

Using nested loops â†’ TLE

ğŸ’¡ Optimal Approach (Greedy + Min-Heap)
Key Idea:

Sort meetings by start time

Use a min-heap to track meeting end times

If earliest meeting ends before next starts â†’ reuse room

Else â†’ allocate new room

ğŸ§  Algorithm (Step-by-Step)

Sort intervals by start time

Create a min-heap to store end times

Add the first meeting end time

For each next meeting:

If start >= heap.peek() â†’ remove heap top (reuse room)

Add current meeting end time

Heap size = number of rooms needed

â± Complexity

Time: O(n log n)

Space: O(n)

âœ… Java Code
import java.util.*;

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) return 0;

        // Step 1: Sort by start time
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        // Step 2: Min-heap to store end times
        PriorityQueue<Integer> heap = new PriorityQueue<>();

        // Step 3: Add first meeting
        heap.add(intervals[0][1]);

        // Step 4: Process remaining meetings
        for (int i = 1; i < intervals.length; i++) {
            int start = intervals[i][0];
            int end = intervals[i][1];

            // If room is free, reuse it
            if (start >= heap.peek()) {
                heap.poll();
            }

            // Allocate room
            heap.add(end);
        }

        // Step 5: Number of rooms used
        return heap.size();
    }
}

ğŸ” Line-by-Line Explanation
Arrays.sort(intervals, (a, b) -> a[0] - b[0]);


ğŸ‘‰ Sort meetings by start time

PriorityQueue<Integer> heap = new PriorityQueue<>();


ğŸ‘‰ Min-heap stores earliest finishing meeting

heap.add(intervals[0][1]);


ğŸ‘‰ First meeting needs a room

if (start >= heap.peek())


ğŸ‘‰ If earliest meeting ends before current starts â†’ reuse room

heap.poll();


ğŸ‘‰ Remove finished meeting

heap.add(end);


ğŸ‘‰ Add current meetingâ€™s end time

return heap.size();


ğŸ‘‰ Heap size = max rooms used at any time

ğŸ§ª FULL WALKTHROUGH (Detailed)
Input
intervals = [[0,30],[5,10],[15,20]]

Step 1: Sort
[[0,30],[5,10],[15,20]]

Step 2: Process
Meeting	Heap (end times)	Rooms
0â€“30	[30]	1
5â€“10	[10,30]	2
15â€“20	[20,30]	2
âœ… Final Output
2

ğŸ¯ What to Say in Interview

â€œI sort by start time and use a min-heap to track the earliest finishing meeting.
If a meeting starts after a room is free, I reuse it; otherwise, I allocate a new room.â€

Clean. Confident. Correct. âœ…
