Question 4: Merge k Sorted Lists
Problem Statement

You are given k sorted linked lists. Merge them into one sorted linked list and return its head.

Example:

Input: lists = [
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6

Explanation: All lists merged into one sorted linked list.

Algorithm (Min-Heap / PriorityQueue Approach)

Idea:

Use a Min Heap (PriorityQueue) to always get the node with the smallest value among the current heads of the k lists.

This ensures we maintain the sorted order while merging.

Steps:

Create a priority queue (min-heap) that sorts nodes by value.

Add the head of each list into the heap.

Initialize a dummy node to build the merged list.

While the heap is not empty:

Extract the smallest node.

Append it to the merged list.

If this node has a next node, add it to the heap.

Return dummy.next as the head of the merged list.

Time Complexity:

Each node is pushed/popped from heap once → O(N log k)
where N = total nodes, k = number of lists.

Space Complexity: O(k) for the heap.

Java Code
import java.util.*;

class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

public class MergeKSortedLists {

    public static ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;

        // Step 1: Min Heap to store nodes
        PriorityQueue<ListNode> heap = new PriorityQueue<>(lists.length, Comparator.comparingInt(a -> a.val));

        // Step 2: Add head of each list to heap
        for (ListNode node : lists) {
            if (node != null) heap.add(node);
        }

        // Step 3: Dummy node to start merged list
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        // Step 4: Merge nodes
        while (!heap.isEmpty()) {
            ListNode smallest = heap.poll(); // Get node with smallest value
            current.next = smallest;         // Append to merged list
            current = current.next;

            if (smallest.next != null) {     // If node has next, add it to heap
                heap.add(smallest.next);
            }
        }

        return dummy.next;
    }

    // Helper to print list
    public static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + "->");
            head = head.next;
        }
        System.out.println("null");
    }

    public static void main(String[] args) {
        ListNode l1 = new ListNode(1);
        l1.next = new ListNode(4);
        l1.next.next = new ListNode(5);

        ListNode l2 = new ListNode(1);
        l2.next = new ListNode(3);
        l2.next.next = new ListNode(4);

        ListNode l3 = new ListNode(2);
        l3.next = new ListNode(6);

        ListNode[] lists = new ListNode[]{l1, l2, l3};
        ListNode merged = mergeKLists(lists);

        System.out.print("Merged List: ");
        printList(merged); // Output: 1->1->2->3->4->4->5->6->null
    }
}

Code Explanation Line by Line

PriorityQueue<ListNode> heap = new PriorityQueue<>(...)

Min-heap to always get the node with smallest value.

for (ListNode node : lists) { if (node != null) heap.add(node); }

Add the head of each list into the heap if it exists.

ListNode dummy = new ListNode(0); ListNode current = dummy;

Dummy node to simplify building the merged list.

while (!heap.isEmpty()) { ... }

While heap has nodes, keep extracting the smallest node.

ListNode smallest = heap.poll();

Get node with the smallest value from the heap.

current.next = smallest; current = current.next;

Append it to the merged list and move current pointer.

if (smallest.next != null) heap.add(smallest.next);

If the smallest node has a next node, add it to the heap to continue merging.

return dummy.next;

Return head of merged list (skip dummy node).

Example Walkthrough
Input lists:
l1: 1->4->5
l2: 1->3->4
l3: 2->6

Heap initially: [1(l1), 1(l2), 2(l3)]

Step-by-step:
1. Pop 1(l1), append to merged list → heap: [1(l2),2(l3),4(l1)]
2. Pop 1(l2), append → heap: [2(l3),4(l1),3(l2)]
3. Pop 2(l3), append → heap: [3(l2),4(l1),6(l3)]
4. Continue popping in order: 3,4,4,5,6
Merged List: 1->1->2->3->4->4->5->6


✅ Efficiently merges k lists in sorted order using a heap.
