Question 5: Sliding Window Maximum
Problem Statement

Given an array of integers nums and a window size k, find the maximum element in each sliding window of size k as the window moves from left to right.

Example:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

Explanation:
Window positions:
[1,3,-1] -> max = 3
[3,-1,-3] -> max = 3
[-1,-3,5] -> max = 5
[-3,5,3] -> max = 5
[5,3,6] -> max = 6
[3,6,7] -> max = 7

Algorithm (Deque Approach)

Idea:

Use a deque to store indices of elements in a way that the front of the deque always has the largest element for the current window.

Remove elements from deque that are out of the current window or smaller than the current element.

Steps:

Initialize a deque to store indices.

Iterate through the array:

Remove indices from front if they are out of the current window.

Remove indices from back if nums[current] ≥ nums[deque.back] (maintain descending order).

Add current index to deque.

If i >= k-1, record nums[deque.front] as the max for this window.

Time Complexity: O(N) because each element is added and removed at most once.
Space Complexity: O(k) for the deque.

Java Code
import java.util.*;

public class SlidingWindowMaximum {

    public static int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0) return new int[0];
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>(); // stores indices

        for (int i = 0; i < n; i++) {
            // Remove indices out of the current window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // Remove smaller elements from the back
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }

            deque.offerLast(i); // Add current index

            // Record max for window
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int[] nums = {1,3,-1,-3,5,3,6,7};
        int k = 3;
        int[] result = maxSlidingWindow(nums, k);
        System.out.println("Sliding Window Maximum: " + Arrays.toString(result));
        // Output: [3, 3, 5, 5, 6, 7]
    }
}

Code Explanation Line by Line

Deque<Integer> deque = new LinkedList<>();

Stores indices of array elements in decreasing order of value.

while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) deque.pollFirst();

Remove indices that are out of the current window.

while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) deque.pollLast();

Remove indices whose values are smaller than current element, because they cannot be max.

deque.offerLast(i);

Add the current index at the back.

if (i >= k - 1) result[i - k + 1] = nums[deque.peekFirst()];

Once the window has reached size k, record the max element (front of deque).

Example Walkthrough
nums = [1,3,-1,-3,5,3,6,7], k = 3

Step-by-step using deque (indices):
i=0: deque=[0] -> window not full yet
i=1: deque=[1] (1 removed, 3 bigger) -> window not full
i=2: deque=[1,2] -> first max: nums[1]=3
i=3: deque=[1,2,3] -> remove out of window 1? no -> max nums[1]=3
i=4: deque=[4] -> 5 replaces smaller elements -> max 5
i=5: deque=[4,5] -> max 5
i=6: deque=[6] -> max 6
i=7: deque=[7] -> max 7

Output: [3,3,5,5,6,7]


✅ Efficient solution for large arrays with O(N) complexity, frequently asked in Google, Amazon, and Microsoft interviews.
