FIND THE DUPLICATE NUMBER (Without Modifying Array)

ğŸ’¥ Asked in Amazon, Google, Microsoft
Tests Linked List Cycle Detection concept applied to arrays

ğŸ§  Problem Statement

You are given an integer array nums containing n + 1 integers where:

Each integer is in the range [1, n]

There is only one repeated number

The array may contain that number more than once

You must not modify the array

You must use O(1) extra space

Return the duplicate number.

Example
Input: nums = [1, 3, 4, 2, 2]
Output: 2

ğŸš« Why This Problem Is Tricky (Interviewers Love It)

You CANNOT:

Sort the array

Use HashSet / extra array

Modify elements

So brute force and hashing are âŒ

ğŸ’¡ Key Insight (Interview GOLD)

ğŸ‘‰ Treat the array as a linked list

Index â†’ node

nums[i] â†’ next pointer

Duplicate creates a cycle

ğŸ“Œ Then use Floydâ€™s Tortoise & Hare Algorithm

ğŸ§  Algorithm (Floydâ€™s Cycle Detection)
Phase 1: Detect the cycle

Slow pointer moves 1 step

Fast pointer moves 2 steps

They will meet inside the cycle

Phase 2: Find cycle entrance

Move one pointer to start

Move both 1 step at a time

Meeting point = duplicate number

â± Complexity

Time: O(n)

Space: O(1)

âœ… Java Code
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[0];

        // Phase 1: Find intersection
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        // Phase 2: Find entrance to cycle
        slow = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}

ğŸ” Line-by-Line Explanation
int slow = nums[0];
int fast = nums[0];


ğŸ‘‰ Initialize both pointers from the first element

slow = nums[slow];


ğŸ‘‰ Move slow pointer 1 step

fast = nums[nums[fast]];


ğŸ‘‰ Move fast pointer 2 steps

do { ... } while (slow != fast);


ğŸ‘‰ Loop until they meet inside the cycle

slow = nums[0];


ğŸ‘‰ Reset slow pointer to start for phase 2

while (slow != fast)


ğŸ‘‰ Move both one step at a time

return slow;


ğŸ‘‰ Entry point of cycle = duplicate number

ğŸ§ª FULL WALKTHROUGH (Very Important)
Input
nums = [1, 3, 4, 2, 2]

Visual Representation
Index: 0  1  2  3  4
Value: 1  3  4  2  2

0 â†’ 1 â†’ 3 â†’ 2 â†’ 4
          â†‘       â†“
          â† â† â† â†

Phase 1: Detect cycle
Step	slow	fast
Init	1	1
1	3	2
2	2	2 â† meet
Phase 2: Find entry

Reset slow = 1

Step	slow	fast
1	3	4
2	2	2 â† meet
ğŸ¯ Final Answer
2

ğŸ§  Interview Talking Points

Say this confidently ğŸ‘‡

â€œThis array behaves like a linked listâ€

â€œDuplicate creates a cycleâ€

â€œUsing Floydâ€™s Cycle Detection gives O(1) spaceâ€

â€œEntry of cycle equals duplicateâ€
