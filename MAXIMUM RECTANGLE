âœ… Maximal Rectangle (Largest Rectangle of 1s in a Binary Matrix)

ğŸ“ Pattern: Stack + DP
ğŸ“ Asked in: Amazon, Google, Microsoft, Meta
ğŸ“ Difficulty: Hard
ğŸ“ Why interviewers love it: Combines 2 problems into 1

ğŸ§© Problem Statement

Given a binary matrix filled with 0s and 1s, find the largest rectangle containing only 1s and return its area.

ğŸ“Œ Example
Input
matrix =
[
  ['1','0','1','0','0'],
  ['1','0','1','1','1'],
  ['1','1','1','1','1'],
  ['1','0','0','1','0']
]

Output
6

Explanation

Largest rectangle of 1s:

1 1 1
1 1 1


Area = 6

ğŸš« Brute Force?

Try every rectangle â†’ O(nâ´) âŒ absolutely not

âœ… Optimal Approach
ğŸ§  Key Insight

Treat each row as the base of a histogram

Build histogram heights row by row

On each row, apply Largest Rectangle in Histogram

Track maximum area

ğŸªœ Algorithm Steps

Initialize an array heights[] with size = number of columns

For each row:

If matrix cell is 1 â†’ increase height

If 0 â†’ reset height

Apply stack-based histogram algorithm

Update global maximum area

â± Time & Space Complexity

Time: O(rows Ã— cols)

Space: O(cols)

ğŸ’» JAVA CODE (INTERVIEW READY & CLEAN)
import java.util.Stack;

public class MaximalRectangle {

    public static int maximalRectangle(char[][] matrix) {

        if (matrix.length == 0) return 0;

        int cols = matrix[0].length;
        int[] heights = new int[cols];
        int maxArea = 0;

        // Process each row as histogram
        for (char[] row : matrix) {

            // Build heights
            for (int i = 0; i < cols; i++) {
                if (row[i] == '1')
                    heights[i]++;
                else
                    heights[i] = 0;
            }

            // Calculate max rectangle in this histogram
            maxArea = Math.max(maxArea, largestRectangleArea(heights));
        }

        return maxArea;
    }

    // Histogram logic
    private static int largestRectangleArea(int[] heights) {

        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        int i = 0;

        while (i <= heights.length) {

            int currHeight = (i == heights.length) ? 0 : heights[i];

            if (stack.isEmpty() || currHeight >= heights[stack.peek()]) {
                stack.push(i++);
            } else {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
        }

        return maxArea;
    }

    public static void main(String[] args) {
        char[][] matrix = {
            {'1','0','1','0','0'},
            {'1','0','1','1','1'},
            {'1','1','1','1','1'},
            {'1','0','0','1','0'}
        };

        System.out.println(maximalRectangle(matrix)); // Output: 6
    }
}

ğŸ” LINE-BY-LINE EXPLANATION
ğŸ”¹ Height Build
if (row[i] == '1')
    heights[i]++;
else
    heights[i] = 0;


â¡ Stack 1s vertically like histogram bars

ğŸ”¹ Stack Logic (Histogram)
currHeight < heights[stack.peek()]


â¡ Time to calculate rectangle area

width = stack.isEmpty() ? i : i - stack.peek() - 1;


â¡ Compute width correctly

ğŸ” DRY RUN (KEY MOMENT)
After 3rd row:
heights = [3,1,3,2,2]


Largest rectangle area = 3 Ã— 2 = 6 âœ…

ğŸ¯ Interview Explanation (CRISP)

â€œI converted each matrix row into a histogram of heights and reused the largest-rectangle-in-histogram stack algorithm.â€
