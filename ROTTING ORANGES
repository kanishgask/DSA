ğŸŠ ROTTING ORANGES

(Breadth-First Search â€“ Multi-Source BFS)

ğŸ”¹ Problem Definition

You are given a 2D grid where:

0 â†’ empty cell

1 â†’ fresh orange

2 â†’ rotten orange

Every minute, a rotten orange rots its 4-directionally adjacent fresh oranges.

ğŸ‘‰ Return the minimum number of minutes required to rot all oranges.
ğŸ‘‰ If it is impossible, return -1.

ğŸ”¹ Example 1
grid = [
  [2,1,1],
  [1,1,0],
  [0,1,1]
]

Output
4

ğŸ”¹ Example 2
grid = [
  [2,1,1],
  [0,1,1],
  [1,0,1]
]

Output
-1


(Some fresh oranges can never rot)

âŒ Brute Force (Not Acceptable)

Simulate minute by minute

Re-scan grid again and again

â± Too slow & messy

âœ… Optimal Approach: MULTI-SOURCE BFS
ğŸ”‘ Key Insight (VERY IMPORTANT ğŸš¨)

All initial rotten oranges start rotting at the same time

This is a level-by-level spread

BFS naturally represents time / levels

ğŸ‘‰ Each BFS level = 1 minute

ğŸ”¹ Algorithm (Step-by-Step)

Traverse grid:

Count total fresh oranges

Push all rotten oranges into queue

If no fresh oranges â†’ return 0

Perform BFS:

For each level (minute)

Rot adjacent fresh oranges

Decrease fresh count

If fresh oranges remain â†’ return -1

Else â†’ return minutes taken

ğŸ”¹ Java Code (Interview Ready)
class Solution {
    public int orangesRotting(int[][] grid) {

        int rows = grid.length;
        int cols = grid[0].length;

        Queue<int[]> queue = new LinkedList<>();
        int fresh = 0;

        // Step 1: scan grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                if (grid[i][j] == 2) {
                    queue.offer(new int[]{i, j});
                }
                if (grid[i][j] == 1) {
                    fresh++;
                }
            }
        }

        // No fresh oranges
        if (fresh == 0) return 0;

        int minutes = 0;
        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};

        // Step 2: BFS
        while (!queue.isEmpty()) {

            int size = queue.size();
            boolean rotted = false;

            for (int i = 0; i < size; i++) {

                int[] cell = queue.poll();

                for (int[] dir : directions) {

                    int r = cell[0] + dir[0];
                    int c = cell[1] + dir[1];

                    if (r >= 0 && r < rows &&
                        c >= 0 && c < cols &&
                        grid[r][c] == 1) {

                        grid[r][c] = 2;
                        fresh--;
                        queue.offer(new int[]{r, c});
                        rotted = true;
                    }
                }
            }

            if (rotted) minutes++;
        }

        return fresh == 0 ? minutes : -1;
    }
}

ğŸ§  LINE-BY-LINE EXPLANATION
Queue<int[]> queue = new LinkedList<>();


âœ” BFS queue
âœ” Stores coordinates {row, col}

if (grid[i][j] == 2)
    queue.offer(new int[]{i, j});


âœ” Add all initial rotten oranges
âœ” Multi-source BFS

int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};


âœ” 4-direction movement (up, down, left, right)

int size = queue.size();


âœ” Size of current BFS level
âœ” Represents one minute

grid[r][c] = 2;
fresh--;


âœ” Rot fresh orange
âœ” Reduce fresh count

if (rotted) minutes++;


âœ” Increment time only if something rotted

return fresh == 0 ? minutes : -1;


âœ” If all oranges rotted â†’ return time
âœ” Else â†’ impossible

ğŸ” Dry Run (Quick)

Initial:

Queue = [(0,0)]
Fresh = 6


Minute 1 â†’ rot neighbors
Minute 2 â†’ spread
Minute 3 â†’ spread
Minute 4 â†’ all rotted

Answer = 4

â± Time & Space Complexity
Type	Complexity
Time	O(m Ã— n)
Space	O(m Ã— n)
ğŸ¯ Interview One-Liner

â€œThis is a multi-source BFS problem where each BFS level represents one minute of rotting.â€
